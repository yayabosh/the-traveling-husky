import java.util.*;

// A Traveler stores algorithms to solve or approximate the traveling salesman problem.
public class Traveler {
    // Stores the Cities in this Traveler's location set.
    public City[] cities;
    // Stores each City's distance from every other City.
    private final double[][] matrix;
    // Stores the number of iterations/operations for the algorithm run on this Traveler.
    public int iterations;

    // Constructs a new Traveler and populates the distance matrix with each city's distance from every other city.
    public Traveler(City[] cities) {
        this.cities = cities;
        this.iterations = 0;
        int n = cities.length;

        this.matrix = new double[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                double distance = distance(cities[i], cities[j]);
                matrix[i][j] = distance;
                matrix[j][i] = distance;
            }
        }
    }

    // Returns the shortest route visiting all cities, i.e. the correct answer to the traveling salesman problem.
    // Note: this algorithm will work with large input sizes but runs in factorial time, so beyond 13 or 14 cities you
    // will be waiting a while for a solution.
    public Route bruteForce() { 
        return bruteForce(new Route(cities.clone(), 0), new Route(null, Double.MAX_VALUE), 0); 
    }

    // Helper method for the brute force approach. Uses a branch-and-bound approach to optimize the algorithm,
    // only recursing if the solution could possibly yield a minimum distance route. Also uses recursive optimization techniques.
    private Route bruteForce(Route current, Route min, int index) {
        if (index == cities.length - 1) {
            current.distance += matrix[current.route[cities.length - 1].id][current.route[0].id];
            if (current.distance < min.distance) return current;
            return min;
        }
        for (int i = index + 1; i < cities.length; i++) {
            City chosen = current.route[i];
            current.route[i] = current.route[index + 1];
            current.route[index + 1] = chosen;

            double newLength = current.distance + matrix[current.route[index].id][chosen.id];
            if (newLength < min.distance) {
                Route potential = new Route(current);
                potential.distance = newLength;
                potential = bruteForce(potential, min, index + 1);
                if (potential.distance < min.distance) min = potential;
            }

            current.route[index + 1] = current.route[i];
            current.route[i] = chosen;
            this.iterations++;
        }
        return min;
    }

    // Returns the "nearest neighbor" route starting from the first city in the array of this Traveler's Cities.
    public Route nearestNeighbor() {
        int n = cities.length;
        City[] route = new City[n];
        double distance = 0;

        route[0] = cities[0];
        Set<City> visited = new HashSet<>();
        visited.add(cities[0]);
        for (int i = 0; i < n - 1; i++) {
            double min = Double.MAX_VALUE;
            int index = -1;
            for (int j = 0; j < n; j++) {
                if (!visited.contains(cities[j])) {
                    if (matrix[route[i].id][j] < min) {
                        min = matrix[route[i].id][j];
                        index = j;
                    }
                    this.iterations++;
                }
            }
            route[i + 1] = cities[index];
            distance += min;
            visited.add(cities[index]);
        }
        return new Route(route, distance + matrix[route[cities.length - 1].id][0]);
    }

    // Returns the route of cities generated by visiting cities by their position on the y-axis (top -> bottom or highest latitudes
    // to lowest latitudes).
    public Route topDown() {
        City[] route = coordSort(cities.clone(), false);
        return new Route(route, distance(route));
    }

    // Returns the route of cities generated by visiting cities by their position on the x-axis (left -> right or lowest longitudes
    // to highest longitudes).
    public Route leftToRight() {
        City[] route = coordSort(cities.clone(), true);
        return new Route(route, distance(route));
    }

    // Returns an array of Cities sorted based on the given axis.
    private City[] coordSort(City[] c, boolean x) {
        this.iterations = c.length * (int) (Math.log(c.length) / Math.log(2));
        Arrays.sort(c, new Comparator<City>() {
            public int compare(City a, City b) {
                return x ? a.longitude < b.longitude ? -1 : a.longitude > b.longitude ?  1 : 0
                         : a.latitude  < b.latitude  ?  1 : a.latitude  > b.latitude  ? -1 : 0;
            }
        });
        return c;
    }

    // Returns a random route.
    public Route random() {
        City[] route = cities.clone();
        double distance = 0;
        Random r = new Random();
        for (int i = route.length - 1; i >= 0; i--) {
            // Fisher-Yates Shuffle
            if (i != 0) {
                int index = r.nextInt(i + 1);
                City c = route[index];
                route[index] = route[i];
                route[i] = c;
            }
            if (i < route.length - 1) distance += matrix[route[i].id][route[i + 1].id];
        }
        this.iterations = cities.length;
        return new Route(route, distance + matrix[route[route.length - 1].id][route[0].id]);
    }

    // Returns the total distance of a route of Cities in kilometers.
    private double distance(City[] r) {
        double distance = 0;
        for (int i = 0; i < r.length - 1; i++) { distance += matrix[r[i].id][r[i + 1].id]; }
        return distance + matrix[r[cities.length - 1].id][r[0].id];
    }

    // Returns the distance between two Cities from start to end in kilometers. 
    // Uses the Haversine formula to compute great-circle distance.
    private static double distance(City start, City end) {
        double lat = Math.toRadians(end.latitude - start.latitude);
        double lon = Math.toRadians(end.longitude - start.longitude);

        double startLat = Math.toRadians(start.latitude);
        double endLat   = Math.toRadians(end.latitude);

        double a = Math.pow(Math.sin(lat / 2), 2) + (Math.pow(Math.sin(lon / 2), 2) * Math.cos(startLat) * Math.cos(endLat));
        double c = 2 * Math.asin(Math.sqrt(a));
        return 6371 * c;
    }
}
